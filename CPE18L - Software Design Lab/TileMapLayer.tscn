extends TileMapLayer

var current_hover: Vector2i = Vector2i.ZERO  # or Vector2i(0,0)

#grid variables
const ROWS : int = 14
const COLS : int = 15
const CELL_SIZE : int = 50

#tilemap variables
var tile_id : int = 0

#layer variables
var mine_layer : int = 0
var number_layer : int = 1
var grass_layer : int = 2
var flag_layer : int = 3
var hover_layer : int = 4

# Atlas coordinates
var mine_atlas := Vector2i(4,0)
var hover_atlas := Vector2i(6, 0)
var number_atlas : Array = generate_number_atlas()

# Array to store mine coordinates
var mine_coords := []

func generate_number_atlas():
	var a : = []
	for i in range(8):
		a.append(Vector2i(i, 1))
	return a

# Called when the node enters the scene tree for the first time
func _ready():
	new_game()
	
#reset game
func new_game():
	clear()
	mine_coords.clear()
	generate_mines()
	generate_numbers()
	#generate_grass()
	
func generate_mines():
	for i in range(get_parent().TOTAL_MINES):
		var mine_pos = Vector2i(randi_range(0, COLS - 1), randi_range(0, ROWS - 1))
		while mine_coords.has(mine_pos):
			mine_pos = Vector2i(randi_range(0, COLS - 1), randi_range(0, ROWS - 1))
		mine_coords.append(mine_pos)
		#add mine to a tilemap
		set_cell(mine_pos, tile_id, mine_atlas)

func generate_numbers():
	for i in get_empty_cells():
		var mine_count : int = 0
		for j in get_all_surrounding_cells(i):
			# check if there is a mine in the cell
			if is_mine(j):
				mine_count += 1
		# once counted, add a number cell in the tilemap
		if mine_count > 0 :
			set_cell(i, tile_id, number_atlas[mine_count - 1])
	# Get empty cells
	# iterate through empty cells and get all surround cells
	# add number of mines inside surroounding cells

func generate_grass():
	for y in range(ROWS):
		for x in range(COLS):
			var toggle = ((x + y) % 2)
			set_cell(Vector2i(x, y), tile_id, Vector2i(3 - toggle, 0))


func get_empty_cells():
	var empty_cells := []
	#iterate over a grid
	for y in range (ROWS):
		for x in range (COLS):
			#check if the cell is empty and add it to the array
			if not is_mine(Vector2i(x, y)):
				empty_cells.append(Vector2i(x,y))
	return empty_cells

func get_all_surrounding_cells(middle_cell):
	var surrounding_cells := []
	var target_cell
	for y in range(3):
		for x in range(3):
			target_cell = middle_cell + Vector2i (x-1, y - 1)
			# skipp cell if it is the one in the middle 
			if target_cell != middle_cell:
				# check that the cell is on the grid
				if (target_cell.x >= 0 and target_cell.x <= COLS - 1
					and target_cell.y >= 0 and target_cell.y <= ROWS - 1):
						surrounding_cells.append(target_cell)
	return surrounding_cells

func _process(delta):
	highlight_cell()
	
func highlight_cell():
	var mouse_pos := local_to_map(get_local_mouse_position())
	# Clear the previous hover (if any and if it is different)
	if current_hover and current_hover != mouse_pos:
		clear_hover(current_hover)

	# Update the hover cell
	current_hover = mouse_pos
	# Optionally check that the mouse is over a valid region.
	set_cell(mouse_pos, tile_id, hover_atlas)
	
func clear_hover(pos: Vector2i):
	# If you have a “grass” tile underneath, re-draw it.
	# (You might need to check your game state or re-call generate_grass() on just that cell.)
	# Here’s an example that uses the same grass logic from your generate_grass():
	var toggle = ((pos.x + pos.y) % 2)
	set_cell(pos, tile_id, Vector2i(3 - toggle, 0))

# Helper functions
func is_mine(pos: Vector2i) -> bool:
	return mine_coords.has(pos)

func is_grass(pos: Vector2i) -> bool:
	return true
